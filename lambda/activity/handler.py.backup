"""
ActivityLambda - 活動記録管理Lambda関数

HealthManagerMCP（Healthmateエコシステム）の活動記録管理を担当。
AgentCore Gateway（MCP）から呼び出され、DynamoDBで活動記録のCRUD操作を実行します。

機能:
- addActivities: 指定した日に新しい活動を追加（複数活動の追加）
- updateActivity: 指定した日の特定の時刻の活動だけを部分的に更新
- updateActivities: 指定した日の全ての活動を完全に置き換え
- deleteActivity: 指定した日の指定した行動を削除
- getActivities: 指定した日のユーザーの行動を取得
- getActivitiesInRange: 指定した期間のユーザーの行動履歴を取得（最大365日）

要件: 要件5-8（活動記録管理）、要件11（データ永続化）、要件12（エラーハンドリング）、要件13（ロギング）
"""

import json
import os
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Literal
import boto3
from botocore.exceptions import ClientError

# DynamoDBクライアント（指数バックオフ付き再試行設定）
from botocore.config import Config

config = Config(
    retries={
        "max_attempts": 3,
        "mode": "standard",  # 指数バックオフ
    }
)

dynamodb = boto3.resource("dynamodb", config=config)
table_name = os.environ.get("ACTIVITIES_TABLE_NAME", "healthmate-activities")
table = dynamodb.Table(table_name)

# 型定義
ActivityType = Literal[
    "wakeUp",        # 起床
    "sleep",         # 就寝
    "exercise",      # 運動
    "meal",          # 食事
    "snack",         # 間食
    "weight",        # 体重測定
    "bodyFat",       # 体脂肪率測定
    "mood",          # 気分記録
    "medication",    # 服薬
    "bowelMovement", # 排便
    "urination",     # 排尿
    "symptoms",      # 症状
    "other"          # その他
]


def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Lambda関数のエントリーポイント
    
    AgentCore Gateway（MCP）から呼び出され、活動記録のCRUD操作を実行します。
    JWTのsubクレームから抽出されたuserIdを使用してDynamoDBにアクセスします。

    Args:
        event: AgentCore Gatewayからのイベント（MCPツール呼び出し）
        context: Lambda実行コンテキスト

    Returns:
        MCP形式のレスポンス
    """
    print(f"[ActivityLambda] Received event: {json.dumps(event, default=str)}")

    try:
        # AgentCore Gateway（MCP）形式のイベントを処理
        parameters = event.copy()
        
        # userIdの検証（必須）
        if "userId" not in parameters:
            raise ValueError("userId is required for all activity operations")
        
        user_id = parameters["userId"]
        print(f"[ActivityLambda] Processing request for userId: {user_id}")
        
        # MCPツール名を推測（パラメータから判断）
        if "activities" in parameters and isinstance(parameters["activities"], list):
            # AddActivitiesまたはUpdateActivities
            # 設計書に従い、デフォルトはAddActivities（既存の活動に追加）
            # UpdateActivitiesは全活動の置き換えなので、明示的に指定される必要がある
            if parameters.get("replaceAll") is True:
                tool_name = "UpdateActivities"
            else:
                tool_name = "AddActivities"
        elif "startDate" in parameters and "endDate" in parameters:
            tool_name = "GetActivitiesInRange"
        elif "date" in parameters and "time" in parameters:
            # UpdateActivityまたはDeleteActivity
            if any(key in parameters for key in ["activityType", "description", "items"]):
                tool_name = "UpdateActivity"
            else:
                tool_name = "DeleteActivity"
        elif "date" in parameters and len([k for k in parameters.keys() if k not in ["userId", "date"]]) == 0:
            # dateのみが指定されている場合は取得
            tool_name = "GetActivities"
        else:
            raise ValueError(f"Cannot determine operation from parameters: {list(parameters.keys())}")
        
        print(f"[ActivityLambda] Inferred operation: {tool_name}")
        
        # ツールに基づいて関数を実行
        if tool_name == "AddActivities":
            result = add_activities(parameters)
        elif tool_name == "UpdateActivity":
            result = update_activity(parameters)
        elif tool_name == "UpdateActivities":
            result = update_activities(parameters)
        elif tool_name == "DeleteActivity":
            result = delete_activity(parameters)
        elif tool_name == "GetActivities":
            result = get_activities(parameters)
        elif tool_name == "GetActivitiesInRange":
            result = get_activities_in_range(parameters)
        else:
            raise ValueError(f"Unknown operation: {tool_name}")
        
        print(f"[ActivityLambda] Operation completed successfully: {tool_name}")
        return result

    except ValueError as e:
        # バリデーションエラー
        error_msg = f"Validation error: {str(e)}"
        print(f"[ActivityLambda] {error_msg}")
        return {
            "success": False,
            "error": error_msg,
            "errorType": "ValidationError"
        }
    except ClientError as e:
        # DynamoDBエラー
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        error_msg = f"Database error ({error_code}): {str(e)}"
        print(f"[ActivityLambda] {error_msg}")
        return {
            "success": False,
            "error": "データベースエラーが発生しました。しばらくしてから再度お試しください。",
            "errorType": "DatabaseError",
            "errorCode": error_code
        }
    except Exception as e:
        # その他のエラー
        error_msg = f"Unexpected error: {str(e)}"
        print(f"[ActivityLambda] {error_msg}")
        return {
            "success": False,
            "error": "予期しないエラーが発生しました。しばらくしてから再度お試しください。",
            "errorType": "InternalError"
        }


def add_activities(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した日に新しい活動を追加する（既存の活動は保持される）

    Args:
        parameters: userId, date, activities (list of activity objects)

    Returns:
        追加結果

    Raises:
        ValueError: 必須パラメータが不足している場合、または活動データが不正な場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    date = parameters.get("date")
    activities = parameters.get("activities", [])

    if not user_id:
        raise ValueError("userId is required")
    if not date:
        raise ValueError("date is required")
    if not activities or not isinstance(activities, list):
        raise ValueError("activities must be a non-empty list")

    print(f"[ActivityLambda] Adding {len(activities)} activities for user: {user_id} on date: {date}")

    # 各活動の検証
    for idx, activity in enumerate(activities):
        if not isinstance(activity, dict):
            raise ValueError(f"Activity at index {idx} must be an object")
        
        required_fields = ["time", "activityType", "description"]
        for field in required_fields:
            if field not in activity:
                raise ValueError(f"Activity at index {idx} must have {field}")
        
            raise ValueError(f"Activity at index {idx}: activityType must be one of: {', '.join(valid_activity_types)}")
        
        # itemsが文字列の場合はリストに変換
        if "items" in activity and isinstance(activity["items"], str):
            activity["items"] = [activity["items"]] if activity["items"] else []
        elif "items" not in activity:
            activity["items"] = []

    now = datetime.now(timezone.utc).isoformat()

    try:
        # 既存のレコードを取得
        response = table.get_item(Key={"userId": user_id, "date": date})

        if "Item" in response:
            # 既存のレコードがある場合、活動リストに追加
            existing_activities = response["Item"].get("activities", [])
            existing_activities.extend(activities)

            table.update_item(
                Key={"userId": user_id, "date": date},
                UpdateExpression="SET activities = :activities, updatedAt = :updatedAt",
                ExpressionAttributeValues={
                    ":activities": existing_activities,
                    ":updatedAt": now,
                },
            )
            print(f"[ActivityLambda] Added {len(activities)} activities to existing record")
        else:
            # 新しいレコードを作成
            table.put_item(
                Item={
                    "userId": user_id,
                    "date": date,
                    "activities": activities,
                    "createdAt": now,
                    "updatedAt": now,
                }
            )
            print(f"[ActivityLambda] Created new record with {len(activities)} activities")

        print(f"[ActivityLambda] Activities added successfully for user: {user_id} on date: {date}")
        return {
            "success": True,
            "message": f"{date}に{len(activities)}件の活動を追加しました",
            "date": date,
            "addedCount": len(activities),
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in add_activities: {error_code} - {str(e)}")
        raise


def update_activity(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した日の特定の時刻の活動だけを部分的に更新する（他の時刻の活動は変更されない）

    Args:
        parameters: userId, date, time, activityType(optional), description(optional), items(optional)

    Returns:
        更新結果

    Raises:
        ValueError: 必須パラメータが不足している場合、または活動が見つからない場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    date = parameters.get("date")
    time = parameters.get("time")
    activity_type = parameters.get("activityType")
    description = parameters.get("description")
    items = parameters.get("items")

    if not user_id:
        raise ValueError("userId is required")
    if not date:
        raise ValueError("date is required")
    if not time:
        raise ValueError("time is required")

    print(f"[ActivityLambda] Updating activity for user: {user_id} on date: {date} at time: {time}")

        if activity_type not in valid_activity_types:
            raise ValueError(f"activityType must be one of: {', '.join(valid_activity_types)}")

    # itemsが文字列の場合はリストに変換
    if isinstance(items, str):
        items = [items] if items else []

    now = datetime.now(timezone.utc).isoformat()

    try:
        # 既存のレコードを取得
        response = table.get_item(Key={"userId": user_id, "date": date})

        if "Item" not in response:
            raise ValueError(f"No activities found for date: {date}")

        activities = response["Item"].get("activities", [])

        # 指定された時刻の活動を検索して更新
        activity_found = False
        updated_activity = None
        for activity in activities:
            if activity["time"] == time:
                activity_found = True
                if activity_type is not None:
                    activity["activityType"] = activity_type
                if description is not None:
                    activity["description"] = description
                if items is not None:
                    activity["items"] = items
                updated_activity = activity.copy()
                break

        if not activity_found:
            raise ValueError(f"No activity found at time: {time} on date: {date}")

        # 更新されたリストを保存
        table.update_item(
            Key={"userId": user_id, "date": date},
            UpdateExpression="SET activities = :activities, updatedAt = :updatedAt",
            ExpressionAttributeValues={
                ":activities": activities,
                ":updatedAt": now,
            },
        )

        print(f"[ActivityLambda] Activity updated successfully for user: {user_id} on date: {date} at time: {time}")
        return {
            "success": True,
            "message": f"{date} {time}の活動を更新しました",
            "date": date,
            "time": time,
            "updatedActivity": updated_activity
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in update_activity: {error_code} - {str(e)}")
        raise


def update_activities(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した日の全ての活動を完全に置き換える（既存の活動は全て削除され、新しいリストで上書きされる）

    Args:
        parameters: userId, date, activities (list of activity objects)

    Returns:
        更新結果

    Raises:
        ValueError: 必須パラメータが不足している場合、または活動データが不正な場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    date = parameters.get("date")
    activities = parameters.get("activities", [])

    if not user_id:
        raise ValueError("userId is required")
    if not date:
        raise ValueError("date is required")
    if not isinstance(activities, list):
        raise ValueError("activities must be a list")

    print(f"[ActivityLambda] Replacing all activities for user: {user_id} on date: {date} with {len(activities)} activities")

    # 各活動の検証
    for idx, activity in enumerate(activities):
        if not isinstance(activity, dict):
            raise ValueError(f"Activity at index {idx} must be an object")
        
        required_fields = ["time", "activityType", "description"]
        for field in required_fields:
            if field not in activity:
                raise ValueError(f"Activity at index {idx} must have {field}")
        
            raise ValueError(f"Activity at index {idx}: activityType must be one of: {', '.join(valid_activity_types)}")
        
        # itemsが文字列の場合はリストに変換
        if "items" in activity and isinstance(activity["items"], str):
            activity["items"] = [activity["items"]] if activity["items"] else []
        elif "items" not in activity:
            activity["items"] = []

    now = datetime.now(timezone.utc).isoformat()

    try:
        # 既存のレコードを取得
        response = table.get_item(Key={"userId": user_id, "date": date})

        if "Item" in response:
            # 既存のレコードがある場合、活動リストを完全に置き換え
            table.update_item(
                Key={"userId": user_id, "date": date},
                UpdateExpression="SET activities = :activities, updatedAt = :updatedAt",
                ExpressionAttributeValues={
                    ":activities": activities,
                    ":updatedAt": now,
                },
            )
            print(f"[ActivityLambda] Replaced existing activities")
        else:
            # 新しいレコードを作成
            table.put_item(
                Item={
                    "userId": user_id,
                    "date": date,
                    "activities": activities,
                    "createdAt": now,
                    "updatedAt": now,
                }
            )
            print(f"[ActivityLambda] Created new record")

        print(f"[ActivityLambda] Activities updated successfully for user: {user_id} on date: {date}")
        return {
            "success": True,
            "message": f"{date}の活動を{len(activities)}件に更新しました",
            "date": date,
            "updatedCount": len(activities),
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in update_activities: {error_code} - {str(e)}")
        raise


def delete_activity(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した日の指定した時刻の活動を削除する

    Args:
        parameters: userId, date, time

    Returns:
        削除結果

    Raises:
        ValueError: 必須パラメータが不足している場合、または活動が見つからない場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    date = parameters.get("date")
    time = parameters.get("time")

    if not user_id:
        raise ValueError("userId is required")
    if not date:
        raise ValueError("date is required")
    if not time:
        raise ValueError("time is required")

    print(f"[ActivityLambda] Deleting activity for user: {user_id} on date: {date} at time: {time}")

    now = datetime.now(timezone.utc).isoformat()

    try:
        # 既存のレコードを取得
        response = table.get_item(Key={"userId": user_id, "date": date})

        if "Item" not in response:
            raise ValueError(f"No activities found for date: {date}")

        activities = response["Item"].get("activities", [])

        # 指定された時刻の活動を削除
        original_length = len(activities)
        deleted_activity = None
        
        # 削除対象の活動を保存してから削除
        for activity in activities:
            if activity["time"] == time:
                deleted_activity = activity.copy()
                break
        
        activities = [a for a in activities if a["time"] != time]

        if len(activities) == original_length:
            raise ValueError(f"No activity found at time: {time} on date: {date}")

        if len(activities) == 0:
            # すべての活動が削除された場合、レコード自体を削除
            table.delete_item(Key={"userId": user_id, "date": date})
            print(f"[ActivityLambda] Deleted entire record (last activity removed)")
        else:
            # 更新されたリストを保存
            table.update_item(
                Key={"userId": user_id, "date": date},
                UpdateExpression="SET activities = :activities, updatedAt = :updatedAt",
                ExpressionAttributeValues={
                    ":activities": activities,
                    ":updatedAt": now,
                },
            )
            print(f"[ActivityLambda] Updated record with remaining {len(activities)} activities")

        print(f"[ActivityLambda] Activity deleted successfully for user: {user_id} on date: {date} at time: {time}")
        return {
            "success": True,
            "message": f"{date} {time}の活動を削除しました",
            "date": date,
            "time": time,
            "deletedActivity": deleted_activity,
            "remainingCount": len(activities)
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in delete_activity: {error_code} - {str(e)}")
        raise


def get_activities(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した日のユーザーの行動を取得する

    Args:
        parameters: userId, date

    Returns:
        活動のリスト

    Raises:
        ValueError: 必須パラメータが不足している場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    date = parameters.get("date")

    if not user_id:
        raise ValueError("userId is required")
    if not date:
        raise ValueError("date is required")

    print(f"[ActivityLambda] Retrieving activities for user: {user_id} on date: {date}")

    try:
        response = table.get_item(Key={"userId": user_id, "date": date})

        if "Item" in response:
            activities = response["Item"].get("activities", [])
            print(f"[ActivityLambda] Retrieved {len(activities)} activities for user: {user_id} on date: {date}")
            return {
                "success": True,
                "date": date,
                "activities": activities,
                "count": len(activities),
            }
        else:
            print(f"[ActivityLambda] No activities found for user: {user_id} on date: {date}")
            return {
                "success": True,
                "date": date,
                "activities": [],
                "count": 0,
            }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in get_activities: {error_code} - {str(e)}")
        raise


def get_activities_in_range(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    指定した期間のユーザーの行動履歴を取得する（最大365日）

    Args:
        parameters: userId, startDate, endDate

    Returns:
        期間内の活動のリスト

    Raises:
        ValueError: 必須パラメータが不足している場合、または日付範囲が不正な場合
        ClientError: DynamoDB操作でエラーが発生した場合
    """
    user_id = parameters.get("userId")
    start_date = parameters.get("startDate")
    end_date = parameters.get("endDate")

    if not user_id:
        raise ValueError("userId is required")
    if not start_date:
        raise ValueError("startDate is required")
    if not end_date:
        raise ValueError("endDate is required")

    print(f"[ActivityLambda] Retrieving activities for user: {user_id} from {start_date} to {end_date}")

    # 日付の妥当性チェック
    try:
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d")
    except ValueError:
        raise ValueError("Invalid date format. Use YYYY-MM-DD")

    if start_dt > end_dt:
        raise ValueError("startDate must be before or equal to endDate")

    # 最大365日間（1年間）の制限
    date_range_days = (end_dt - start_dt).days
    if date_range_days > 365:
        raise ValueError("Date range cannot exceed 365 days")

    try:
        # DynamoDBのクエリで日付範囲を指定
        response = table.query(
            KeyConditionExpression="userId = :userId AND #date BETWEEN :startDate AND :endDate",
            ExpressionAttributeNames={
                "#date": "date"  # 'date'は予約語なのでエイリアスを使用
            },
            ExpressionAttributeValues={
                ":userId": user_id,
                ":startDate": start_date,
                ":endDate": end_date,
            }
        )

        daily_activities = []
        total_activities = 0
        for item in response.get("Items", []):
            activities = item.get("activities", [])
            daily_activities.append({
                "date": item["date"],
                "activities": activities,
                "count": len(activities)
            })
            total_activities += len(activities)

        # 日付順にソート
        daily_activities.sort(key=lambda x: x["date"])

        print(f"[ActivityLambda] Retrieved activities for user: {user_id} - {len(daily_activities)} days, {total_activities} total activities")
        return {
            "success": True,
            "userId": user_id,
            "startDate": start_date,
            "endDate": end_date,
            "dailyActivities": daily_activities,
            "totalDays": len(daily_activities),
            "totalActivities": total_activities,
            "dateRangeDays": date_range_days + 1  # 開始日と終了日を含む日数
        }

    except ClientError as e:
        error_code = e.response.get("Error", {}).get("Code", "Unknown")
        print(f"[ActivityLambda] DynamoDB error in get_activities_in_range: {error_code} - {str(e)}")
        raise
